{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncataMotor = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\ncontroller_1 = Controller(PRIMARY)\nintakeMotor = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\nlimitSwitch = Limit(brain.three_wire_port.c)\nleft_motor_a = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nleft_motor_b = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT17, GearSetting.RATIO_18_1, False)\nright_motor_b = Motor(Ports.PORT19, GearSetting.RATIO_18_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 298.45, 228.6, MM, 0.5)\nrightcata = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\nwingLeft = DigitalOut(brain.three_wire_port.d)\nintakePiston = DigitalOut(brain.three_wire_port.e)\nwingRight = DigitalOut(brain.three_wire_port.f)\ninertialSensor = Inertial(Ports.PORT1)\nencoder_left = Encoder(brain.three_wire_port.a)\nencoder_right = Encoder(brain.three_wire_port.g)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_right_shoulder_control_motors_stopped = True\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, controller_1_right_shoulder_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3\n            # right = axis2\n            drivetrain_left_side_speed = controller_1.axis3.position()\n            drivetrain_right_side_speed = controller_1.axis2.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_1:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_1 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_1:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n            # check the buttonR1/buttonR2 status\n            # to control cataMotor\n            if controller_1.buttonR1.pressing():\n                cataMotor.spin(FORWARD)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif controller_1.buttonR2.pressing():\n                cataMotor.spin(REVERSE)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif not controller_1_right_shoulder_control_motors_stopped:\n                cataMotor.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_right_shoulder_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n\n\n#region Begin project code\n\n# These are used to track the status of the different motors and pistons.\ncataMotorStopped = True \nintakeMotorStopped = True\nwingLeft.set(False) \nwingRight.set(False)  \ninertialSensor.calibrate()\n#intakePiston.set(False)\n\n# define a task that will handle monitoring inputs from controller_1\ndef wingsOut(): # This function opens the robot's wings\n    wingLeft.set(True) # This opens the left wing\n    wingRight.set(True) # This opens the right wing\n\ndef wingsIn(): # This function closes the robot' wings\n    wingLeft.set(False) # This closes the left wing\n    wingRight.set(False) # This closes the right wing\n\ndef intakeIn(): # This function puts the intake into normal position\n    intakePiston.set(False)\n\ndef intakeOut(): # This function puts the intake into collection position\n    intakePiston.set(True)\n\n\ndef catapultDown3(): # This function is used to bring the catapult down\n    # Calling global variables\n    global cataMotorStopped\n    global rightcataStopped\n    # Sets up the motors\n    cataMotor.set_velocity(40, PERCENT) \n    cataMotor.set_max_torque(100, PERCENT)\n    cataMotor.set_stopping(HOLD)\n    rightcata.set_velocity(40, PERCENT) \n    rightcata.set_max_torque(100, PERCENT) \n    rightcata.set_stopping(HOLD) \n      \n # This loop runs until the limit switch is pressed. The program will enter this loop and keep spinning until of the motors become false. When it turns false, the program will skip the while loop.\n    while(limitSwitch.pressing() == 0): \n        print(\"Catapult Going Down - {}\".format(limitSwitch.pressing()))\n        cataMotor.spin(FORWARD)\n        rightcata.spin(FORWARD)\n        cataMotorStopped = False \n        rightcataStopped = False\n        wait(20, MSEC)\n\n # After the limit switch is pressed, the catapult's motor will stop.\n    cataMotor.stop() \n    rightcata.stop() \n    cataMotorStopped = True \n    rightcataStopped = True\n    print(\"Catapult Stopped - {}\".format(limitSwitch.pressing()))\n        \n\n# This function is used to fire the triballs\ndef catapultShoot(): \n    # Calling global variables\n    global cataMotorStopped\n    global rightcataStopped\n    # Setting up the motor\n    cataMotor.set_velocity(50, PERCENT)\n    cataMotor.set_max_torque(100, PERCENT)  \n    cataMotor.set_stopping(COAST)\n    rightcata.set_velocity(50, PERCENT)\n    rightcata.set_max_torque(100, PERCENT)\n    rightcata.set_stopping(COAST)\n    \n\n    # This loop runs until the limit switch is released. The program will enter this loop and keep spinning until of the motors become true. When it turns true, the program will skip the while loop.\n    while(limitSwitch.pressing() == 1):\n        print(\"Catapult trying to shoot\")\n        cataMotor.spin(FORWARD)\n        rightcata.spin(FORWARD)\n        cataMotorStopped = False\n        rightcataStopped = False\n        # wait before repeating the process\n        wait(20, MSEC)\n    # After the limit switch is released, the catapult's motor will stop.\n    cataMotor.stop()\n    rightcata.stop()\n    cataMotorStopped = True\n    rightcataStopped = True\n    print(\"Catapult went up\")\n    wait(0.5, SECONDS)\n    catapultDown3()\n\n# This function is used to spin the intake when L1 is clicked and stop spinning when L1 is clicked again\ndef intakeMotorStartStop():\n    # Calling global variables\n    global intakeMotorStopped\n    # Setting up the motor\n    intakeMotor.set_velocity(60, PERCENT)\n    intakeMotor.set_stopping(COAST)\n    # The program will enter the if part of this statement if intakeMotorStopped is true. When entered, it will spin and turn the motor false. When L1 is clicked again, the program will run but this time, it will enter the else part since it is false. Here, the motor will stop, and exit the statement.\n    if(intakeMotorStopped == True):\n        print(\"starting intake motor\")\n        intakeMotor.spin(FORWARD)\n        intakeMotorStopped = False\n    else:\n        print(\"stopping intake motor\")\n        intakeMotor.stop()\n        intakeMotorStopped = True\n\ndef intakeMotorStartReverse():\n    # Calling global variables\n    global intakeMotorStopped\n    # Setting up the motor\n    intakeMotor.set_velocity(80, PERCENT)\n    intakeMotor.set_stopping(COAST)\n    # The program will enter the if part of this statement if intakeMotorStopped is true. When entered, it will spin and turn the motor false. When L1 is clicked again, the program will run but this time, it will enter the else part since it is false. Here, the motor will stop, and exit the statement.\n    if(intakeMotorStopped == True):\n        print(\"starting intake motor\")\n        intakeMotor.spin(REVERSE)\n        intakeMotorStopped = False\n    else:\n        print(\"stopping intake motor\")\n        intakeMotor.stop()\n        intakeMotorStopped = True\n\n\ndef goForward(degrees, speed):\n    left_motor_a.set_velocity(speed, PERCENT)\n    left_motor_b.set_velocity(speed, PERCENT)\n    right_motor_a.set_velocity(speed, PERCENT)\n    right_motor_b.set_velocity(speed, PERCENT)\n    left_motor_a.set_position(0,DEGREES)\n    right_motor_a.set_position(0, DEGREES)\n    currentDegrees = left_motor_a.position(DEGREES)\n    while(currentDegrees < degrees):\n        drivetrain.drive(FORWARD)\n        wait(20, MSEC)\n        currentDegrees = left_motor_a.position(DEGREES)\n        print(\"Current Degrees - {}\".format(currentDegrees))\n    drivetrain.stop()\n\ndef goBack(degrees):\n    left_motor_a.set_position(0,DEGREES);\n    right_motor_a.set_position(0, DEGREES);\n    currentDegrees = left_motor_a.position(DEGREES)\n    while(currentDegrees < degrees):\n        drivetrain.drive(REVERSE)\n        wait(20, MSEC)\n        currentNegDegrees = left_motor_a.position(DEGREES)\n        currentDegrees = currentNegDegrees * -1\n        print(\"Current Degrees - {}\".format(currentDegrees))\n    drivetrain.stop()\n\ndef turnLeft(degrees):\n    inertialSensor.set_heading(0, DEGREES)\n    drivetrain.turn(LEFT)\n    wait(500,MSEC)\n    print(inertialSensor.heading(DEGREES))\n    while inertialSensor.heading(DEGREES) > degrees:\n        drivetrain.turn(LEFT)\n        wait(20, MSEC)\n        print(\"In while loop - {}\".format(inertialSensor.heading(DEGREES)))\n    print(\"After while loop - {}\".format(inertialSensor.heading(DEGREES)))\n    drivetrain.stop()\n\ndef turnRight(degrees):\n    inertialSensor.set_heading(0, DEGREES)\n    drivetrain.turn(RIGHT)\n    wait(500,MSEC)\n    print(inertialSensor.heading(DEGREES))\n    while inertialSensor.heading(DEGREES) > degrees:\n        drivetrain.turn(RIGHT)\n        wait(20, MSEC)\n        print(\"In while loop - {}\".format(inertialSensor.heading(DEGREES)))\n    print(\"After while loop - {}\".format(inertialSensor.heading(DEGREES)))\n    drivetrain.stop()\n \n# This is used to assign the different functions to different buttons on the controller    \n# Function to run when the \"driver control\" signal is received\ndef driver_control():\n    controller_1.buttonR2.pressed(catapultDown3)\n    controller_1.buttonR1.pressed(catapultShoot)\n    controller_1.buttonL1.pressed(intakeMotorStartStop)\n    controller_1.buttonL2.pressed(intakeMotorStartReverse)\n    controller_1.buttonUp.pressed(intakeOut)\n    controller_1.buttonDown.pressed(intakeIn)\n    controller_1.buttonLeft.pressed(wingsOut)\n    controller_1.buttonRight.pressed(wingsIn)\n\n# Function to run when the \"autonomous\" signal is received\ndef autonomous():\n    brain.screen.print(\"autonomous signal received\")\n    intakeOut()\n    goForward(1400, 40)\n    turnLeft(280)\n    intakeMotorStartReverse()\n    wait(500, MSEC)\n    intakeMotorStartStop()\n    intakeIn()\n    goForward(200, 60)\n    goBack(100)\n    goForward(100, 70)\n    goBack(200)\n\n# Create a new Competition instance\ncompetition = Competition(driver_control, autonomous)\n\n#endregion End Project Code\n","textLanguage":"python","rconfig":[{"port":[20],"name":"cataMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"cataMotor","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"tank","id":"primary"},"triportSourcePort":22},{"port":[11],"name":"intakeMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"limitSwitch","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2,3,17,19,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:2","direction":"rev","gyroType":"none","width":"298.45","unit":"mm","wheelbase":"228.6","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[13],"name":"rightcata","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"wingLeft","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[5],"name":"intakePiston","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"wingRight","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"inertialSensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"encoder_left","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7,8],"name":"encoder_right","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}